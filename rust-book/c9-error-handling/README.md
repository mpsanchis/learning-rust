# Error Handling

Rust groups errors into two major categories:
* Recoverable errors, and
* Unrecoverable errors

Rust also does not have exceptions. Instead, it has the type `Result<T,E>` for recoverable errors, and the `panic!` macro that stops executions in unrecoverable errors.

## 9.1 Unrecoverable errors with panic!

There are two options when panicking:
1. Clear the data by unwinding: walking up the stack and cleaning up the data generated by the functions.
2. Immediately abort without cleaning up.

If in your project you need to make the resultant binary as small as possible, you can switch from unwinding to aborting upon a panic by adding `panic = 'abort' to the appropriate `[profile] sections in your *Cargo.toml* file.

Causing a program to panic will print the error written at the function causing the panic. It might also suggest to set `RUST_BACKTRACE=1`. When set, panicking will also print the stack trace (the functions called until the `panic!`), including the libraries that we import if it panics in somebody else's code.

Backtraces with debug symbols are enabled when running `cargo run` without the `--release` flag, and when running `cargo build`.

## 9.2 Recoverable errors with Result<T,E>

The Result enum looks like this:
```rust
enum Result<T, E> {
  Ok(T),
  Err(E),
}
```

and functions might simply return it, forcing the users to define behaviour in both positive and negative case:
```rust
use std::fs::File;

fn main() {
  let greeting_file_result: Result<File,Error> = File::open("username.txt");
}
```

### Matching on different errors

If the error returned has a "type" attribute, the code could do two levels of `match`ing:
1. Match if result is `Ok(res)` or `Err(e)`
2. Match if `e.kind()` is of some type(s)

An example is `std::fs` and `std::io`:
```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("username.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("username.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            },
            other_error => {
                panic!("Problem opening the file: {other_error:?}");
            }
        },
    };
}
```


### Alternatives to "match"

An equivalent code to the one above, without `match`, can be obtained with `unwrap_or_else`:
```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("username.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("username.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
```

If we want to `panic!` when an error is found, we can directly use the `unwrap` method on `Result<T,E>`. The following code:
```rust
let greeting_file = File::open("username.txt").unwrap();
```
will return the file, or `panic!` if not found.

The `expect` method calls `panic!` with a custom error message:
```rust
let greeting_file = File::open("username.txt").expect("username.txt was not found in this project");
```

### Propagating errors

Self-written functions can and should sometimes return a `Result<T,E>` object. An example is:
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
  let username_file_result = File::open("username.txt");

  let mut username_file = match username_file_result {
    Ok(file) => file,
    Err(e) => return Err(e),
  };

  let mut username = String::new();

  match username_file.read_to_string(&mut username) {
    Ok(_) => Ok(username),
    Err(e) => Err(e),
  }
}
```

which might return the *username* read in the file, but might also return some kind of `std::io::Error`.

#### Propagating errors with the '?' operator

The function above can be rewritten adding the *?* when calling both functions that might return an error. It just adds the `return Err(e)` and simplifies code:
```rust
let mut username_file = File::open("username.txt")?;
let mut username = String::new();
username_file.read_to_string(&mut username)?;
Ok(username)
```

This can be simplified even further if we don't need the intermediate variable `username_file`:
```rust
let mut username = String::new();
File::open("username.txt")?.read_to_string(&mut username)?;
Ok(username)
```

Side note: in this specific case, the `std::fs` library provides the method `read_to_string<P: AsRef<Path>>(path: P) -> Result<String>` that allows us to implement the function as a one liner:
```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
  fs::read_to_string("username.txt")
}
```

##### Transforming errors with the '?' operator

An extra step that the *?* operator does is to call the `from` function defined in the `std::convert::From` trait, in order to match the `Error` returned in the function called internally with the `Error` returned by our function.

This means that if we return `MyError` but we are using *?* with a function that returns `std::io::Error`, then `MyError` must declare `impl From<io::Error> for MyError`. See *question_mark_operator.rs* for an example.

Notes about the *?* operator:
* It can also be used with `Option<T>`: `text.lines().next()?.chars().last()`. It does the same: returns the value `T` if it exists, otherwise returns an early `Option<None>`.
* It cannot be used in functions that don't return `Option` or `Result` (or another type that implements `FromResidual`).